# --- Purpose --- 
# Be proactively notified when storage growth of any cluster in your fleet is projected to exceed capacity within a certain number of months (6 months is the default)
#
# --- Required Steps ---
# ALL USERS need to populate the $APIkey variable with an API key they generated from fleet.scalecomputing.com.
#
# --- Optional Configuration ---
# Customize the $alertMessage as needed for your preferences
# Slack Alerting users: be sure to input your webhook URL generated by the workflow builder,and to have your workflow accept "text" as a variable. https://slack.com/help/articles/360035692513-Guide-to-Slack-Workflow-Builder?utm_source=slack&utm_medium=prod&utm_campaign=hc
# Email Alerting users: fill out the relevant fields below
# Note: If you have many clusters, you may need to implement some waits to avoid hitting API rate limits
# Increase sensitivity by reducing the $utilizationUriBase query filter from -30d down to -14d, or even -7d, or decrease sensitivity by increasing to -90 or -365.
# Adjust the $predictionThresholdMonths variable to make the alert threshold more or less aggressive
#
# --- How this script works ---
# This script iterates through an organization's cluster list (up to 200, could be enhanced to iterate through more, though a wait may need to be added to avoid hitting rate limits)
# It then retrieves the current storage capacity, and the last 30 days utilization.
# The utilization data is weighted such that the oldest and newest data in the retrieval range is higher weighted than data in the middle
# The intent here is to ensure that a now resolved spike or drop in storage has less weight that the current storage.

# --- Alerting Configuration ---
$predictionThresholdMonths = 12 #How proactive do you want to be?
$slackWebhookUrl = "YOUR_WEBHHOOK_URL"  # Replace with your Slack webhook URL (if using Slack)
$smtpServer = "YOUR_SMTP_SERVER"             # Replace with your SMTP server address (if using email)
$smtpPort = 587                               # Common SMTP port (adjust if needed)
$smtpUsername = "YOUR_EMAIL_USERNAME"         # Replace with your email username
$smtpPassword = "YOUR_EMAIL_PASSWORD"         # Replace with your email password
$fromEmail = "your.monitoring@example.com"   # Replace with your "From" email address
$toEmail = "your.alerts@example.com"       # Replace with your "To" email address
$emailSubject = "Storage Capacity Prediction Alert"
# --- End Alerting Configuration ---

# API Key
$apikey = "YOUR_API_KEY"

# API Endpoint URLs
$clustersUri = "https://api.scalecomputing.com/api/v2/clusters?offset=0&limit=200"
$capacityUriBase = "https://api.scalecomputing.com/api/v2/metrics?metricType=cluster_storage_capacity&query=id%3A%3D{0}&from=-30d&to=0"
$utilizationUriBase = "https://api.scalecomputing.com/api/v2/metrics?metricType=cluster_storage_utilization&query=id%3A%3D{0}&from=-30d&to=0"

# Headers
$headers = @{
    "Accept" = "application/json"
    "API-Key" = $apikey
}

# --- Functions for Sending Alerts ---

function Send-SlackAlert {
    param(
        [Parameter(Mandatory=$true)]
        [string]$WebhookUrl,
        [Parameter(Mandatory=$true)]
        [string]$Message
    )
    try {
        $body = @{ text = $Message } | ConvertTo-Json
        Invoke-RestMethod -Uri $WebhookUrl -Method Post -Body $body -ContentType 'application/json' | Out-Null
        Write-Host "Slack alert sent."
    } catch {
        Write-Error "Error sending Slack alert: $_"
    }
}

function Send-EmailAlert {
    param(
        [Parameter(Mandatory=$true)]
        [string]$SmtpServer,
        [Parameter(Mandatory=$true)]
        [int]$SmtpPort,
        [Parameter(Mandatory=$true)]
        [string]$Username,
        [Parameter(Mandatory=$true)]
        [string]$Password,
        [Parameter(Mandatory=$true)]
        [string]$From,
        [Parameter(Mandatory=$true)]
        [string]$To,
        [Parameter(Mandatory=$true)]
        [string]$Subject,
        [Parameter(Mandatory=$true)]
        [string]$Body
    )
    try {
        $smtpClient = New-Object Net.Mail.SmtpClient($SmtpServer, $SmtpPort)
        $smtpClient.EnableSsl = $true
        $smtpClient.Credentials = New-Object System.Net.NetworkCredential($Username, $Password)
        $mailMessage = New-Object Net.Mail.MailMessage($From, $To, $Subject, $Body)
        $smtpClient.Send($mailMessage)
        Write-Host "Email alert sent to $To."
    } catch {
        Write-Error "Error sending email alert: $_"
    }
}

try {
    # Get all clusters (up to 200)
    $clustersResponse = Invoke-RestMethod -Uri $clustersUri -Method Get -Headers $headers
    $clusters = $clustersResponse.items

    if ($clusters -and $clusters.Count -gt 0) {
        foreach ($cluster in $clusters) {
            $clusterID = $cluster.id
            $clusterName = $cluster.name

            Write-Host "Processing cluster: '$clusterName' (ID: '$clusterID')"

            # Get Storage Capacity for the current cluster
            $capacityUri = $capacityUriBase -f $clusterID
            $capacityResponse = Invoke-RestMethod -Uri $capacityUri -Method Get -Headers $headers
            $capacityDataPoints = $capacityResponse.items[0].pointData

            $latestCapacityBytes = $null
            if ($capacityDataPoints -and $capacityDataPoints.Count -gt 0) {
                $latestCapacityBytes = ($capacityDataPoints | Sort-Object timestamp -Descending | Select-Object -First 1).available
                $capacityGB = [Math]::Round($latestCapacityBytes / 1GB, 2)
            } else {
                Write-Warning "Could not retrieve storage capacity data for cluster '$clusterName'. Skipping prediction for this cluster."
                continue # Move to the next cluster
            }

            # Get Storage Utilization for the current cluster
            $utilizationUri = $utilizationUriBase -f $clusterID
            $utilizationResponse = Invoke-RestMethod -Uri $utilizationUri -Method Get -Headers $headers
            $utilizationDataPoints = $utilizationResponse.items[0].pointData
            $utilizationData = $utilizationDataPoints | Sort-Object timestamp | Select-Object @{Name='x';Expression={$_.timestamp}}, @{Name='y';Expression={$_.used}}
            $validUtilizationData = $utilizationData | Where-Object {$_.y -ne $null}

            if ($validUtilizationData.Count -gt 1) {
                # Extract timestamp (as numerical value) and utilization in bytes
                $dataPoints = $validUtilizationData | Sort-Object x | Select-Object @{Name='x';Expression={$_.x}}, @{Name='y';Expression={$_.y}}
                $n = $dataPoints.Count

                # Assign weights based on position (emphasizing first and last)
                $weights = @()
                for ($i = 0; $i -lt $n; $i++) {
                $normalizedPosition = $i / ($n - 1) # Ranges from 0 to 1
                $weight = 0.1 + (0.9 * (1 - 4 * ([Math]::Abs($normalizedPosition - 0.5)))) # Higher at ends, lower in middle
                if ($n -eq 1) { $weight = 1 } # Handle single data point case
                $weights += $weight
                }

                # Calculate weighted sums
                $weightedSumX = 0
                $weightedSumY = 0
                $weightedSumXY = 0
                $weightedSumX2 = 0
                $weightedSumWeights = 0

                for ($i = 0; $i -lt $n; $i++) {
                    $wx = $weights[$i] * $dataPoints[$i].x
                    $wy = $weights[$i] * $dataPoints[$i].y
                    $weightedSumX += $wx
                    $weightedSumY += $wy
                    $weightedSumXY += $wx * $dataPoints[$i].y
                    $weightedSumX2 += $wx * $dataPoints[$i].x
                    $weightedSumWeights += $weights[$i]
                }

                # Calculate weighted slope and intercept
                $denominator = ($weightedSumWeights * $weightedSumX2) - ($weightedSumX * $weightedSumX)
                if ($denominator -ne 0) {
                    $weightedSlope = (($weightedSumWeights * $weightedSumXY) - ($weightedSumX * $weightedSumY)) / $denominator
                    $weightedIntercept = ($weightedSumY - ($weightedSlope * $weightedSumX)) / $weightedSumWeights

                    if ($weightedSlope -gt 0) {
                        $timeToCapacity = ($latestCapacityBytes - $weightedIntercept) / $weightedSlope
                        if ($timeToCapacity -gt 0) { # Ensure the predicted time is in the future (positive milliseconds)
                            # Add checks for a reasonable range for $timeToCapacity (e.g., not excessively large)
                            if ($timeToCapacity -lt (3155760000000 * 1)) { # Approximately 10 years in milliseconds (adjust as needed)
                                try {
                                    $predictionTime = [datetime]::new(1970, 1, 1, 0, 0, 0, [DateTimeKind]::Utc).AddMilliseconds($timeToCapacity)
                                    $timeDifference = $predictionTime - (Get-Date)
                                    $monthsUntilPrediction = ($timeDifference.TotalDays / 30.44)

                                    if ($monthsUntilPrediction -lt $predictionThresholdMonths -and $monthsUntilPrediction -gt 0) {
                                        $alertMessage = "Based on the last 30 days trajectory, storage on cluster '$clusterName' (ID: '$clusterID') might reach capacity around $($predictionTime.ToLocalTime()) within the next $($predictionThresholdMonths) months. Recover space or add additional storage soon: https://fleet.scalecomputing.com/clusters/$clusterID"
                                        Write-Warning $alertMessage

                                        # Send Alert
                                        Send-SlackAlert -WebhookUrl $slackWebhookUrl -Message $alertMessage
                                        # Send-EmailAlert ...
                                    }
                                } catch {
                                    Write-Error "Error converting predicted time to DateTime: $_"
                                }
                            } else {
                                Write-Warning "Predicted time to capacity is too far in the future or invalid."
                            }
                        } else {
                            Write-Host "Predicted time to capacity is not in the future based on the current weighted trend."
                        }
                    } # Closing brace for if ($weightedSlope -gt 0)
                } else {
                    Write-Warning "Cannot calculate trend for cluster '$clusterName' (denominator is zero)."
                }
            } else {
                Write-Warning "Not enough valid storage utilization data points for cluster '$clusterName' (at least 2 required) for trend analysis."
            }
        }
    }
} catch {
    Write-Error "An error occurred during the API request or data processing:"
    Write-Error $_
}
